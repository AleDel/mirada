// IMPORTANT: this file is auto-generated by npm run ops-metadata script

import { ChainBase, Params } from './chainBase'
import { AdaptiveThreshold, AdaptiveThresholdOptions, BilateralFilter, BilateralFilterOptions, Bitwise, BitwiseOptions, BoxFilter, BoxFilterOptions, Canny, CannyOptions, Circle, CircleOptions, ConvertTo, ConvertToOptions, Edge, EdgeOptions, Ellipse, EllipseOptions, FloodFill, FloodFillOptions, GaussianBlur, GaussianBlurOptions, HistEqualization, HistEqualizationOptions, InRange, InRangeOptions, Line, LineOptions, Math, MathOptions, MedianBlur, MedianBlurOptions, MorphologyEx, MorphologyExOptions, Rectangle, RectangleOptions, ReplaceColor, ReplaceColorOptions, Threshold, ThresholdOptions, WarpAffine, WarpAffineOptions, WarpPerspective, WarpPerspectiveOptions, CvtColor, CvtColorOptions, Pyr, PyrOptions, ToRgba, ToRgbaOptions, Roi, RoiOptions, Cartoonize, CartoonizeOptions, Wave, WaveOptions, HoughLinesP, HoughLinesPOptions, Filter2D, Filter2DOptions } from '..'

export class Chain extends ChainBase {
  /**
   * transforms a grayscale image to a binary image
   */
  adaptiveThreshold(...args: Params<AdaptiveThresholdOptions>) {
    return this.handle(args, AdaptiveThreshold)
  }
  
  /**
   * The function applies bilateral filtering to the input image, as described in bilateralFilter can reduce unwanted noise very well while keeping edges fairly sharp. However, it is very slow compared to most filters. 
  
  Sigma values*: For simplicity, you can set the 2 sigma values to be the same. If they are small (< 10), the filter will not have much effect, whereas if they are large (> 150), they will have a very strong effect, making the image look "cartoonish".
  
  Filter size*: Large filters (d > 5) are very slow, so it is recommended to use d=5 for real-time applications, and perhaps d=9 for offline applications that need heavy noise filtering.
   */
  bilateralFilter(...args: Params<BilateralFilterOptions>) {
    return this.handle(args, BilateralFilter)
  }
  
  /**
   * 
   */
  bitwise(...args: Params<BitwiseOptions>) {
    return this.handle(args, Bitwise)
  }
  
  /**
   * smooths an image. Unnormalized box filter is useful for computing various integral characteristics over each pixel neighborhood, such as covariance matrices of image derivatives (used in dense optical flow algorithms, and so on). 
   */
  boxFilter(...args: Params<BoxFilterOptions>) {
    return this.handle(args, BoxFilter)
  }
  
  /**
   * finds edges in the input image and marks them in the output map edges using the Canny algorithm. The smallest value between threshold1 and threshold2 is used for edge linking. The largest value is used to find initial segments of strong edges
   */
  canny(...args: Params<CannyOptions>) {
    return this.handle(args, Canny)
  }
  
  /**
   * Draws a simple or filled circle with a given center and radius.
   */
  circle(...args: Params<CircleOptions>) {
    return this.handle(args, Circle)
  }
  
  /**
   * converts source pixel values to the target data type.
   */
  convertTo(...args: Params<ConvertToOptions>) {
    return this.handle(args, ConvertTo)
  }
  
  /**
   * facade around cv.Sobel, cv.Laplacian and cv.Scharr
   */
  edge(...args: Params<EdgeOptions>) {
    return this.handle(args, Edge)
  }
  
  /**
   * Draws a simple or filled Ellipse with a given center size and rotation angle.
   */
  ellipse(...args: Params<EllipseOptions>) {
    return this.handle(args, Ellipse)
  }
  
  /**
   * This is a high level API for flood fill given color or image starting from given [seed] coords and involves several opencv operations. 
   */
  floodFill(...args: Params<FloodFillOptions>) {
    return this.handle(args, FloodFill)
  }
  
  /**
   * convolves the source image with the specified Gaussian kernel. In-place filtering is supported.
   */
  gaussianBlur(...args: Params<GaussianBlurOptions>) {
    return this.handle(args, GaussianBlur)
  }
  
  /**
   * Applies histogram equalization using cv.equalizeHist or cv.CLAHE. In case src image has multiple channels, equalization is applied on each of them independently and then the result is merged
   */
  histEqualization(...args: Params<HistEqualizationOptions>) {
    return this.handle(args, HistEqualization)
  }
  
  /**
   * [dst] is set to 255 (all 1 -bits) if [src] is within the specified 1D, 2D, 3D, ... box and 0 otherwise.
   */
  inRange(...args: Params<InRangeOptions>) {
    return this.handle(args, InRange)
  }
  
  /**
   * Draws the line segment between pt1 and pt2 points in the image.
   */
  line(...args: Params<LineOptions>) {
    return this.handle(args, Line)
  }
  
  /**
   * performs math operations per pixel on images, like add, subtract, divide, addWeighted and multiply
   */
  math(...args: Params<MathOptions>) {
    return this.handle(args, Math)
  }
  
  /**
   * smoothes an image using the median filter with the ksize x ksize aperture.
   */
  medianBlur(...args: Params<MedianBlurOptions>) {
    return this.handle(args, MedianBlur)
  }
  
  /**
   * perform advanced morphological transformations using an erosion and dilation as basic operations. In case of multi-channel images, each channel is processed independently.
   */
  morphologyEx(...args: Params<MorphologyExOptions>) {
    return this.handle(args, MorphologyEx)
  }
  
  /**
   * Draws the Rectangle segment between pt1 and pt2 points in the image.
   */
  rectangle(...args: Params<RectangleOptions>) {
    return this.handle(args, Rectangle)
  }
  
  /**
   * Will replace pixels within given boundaries with given color or image's pixels
   */
  replaceColor(...args: Params<ReplaceColorOptions>) {
    return this.handle(args, ReplaceColor)
  }
  
  /**
   * Applies fixed-level thresholding to a multiple-channel array. The function is typically used to get a bi-level (binary) image out of a grayscale image or for removing a noise, that is, filtering out pixels with too small or too large values. There are several types of thresholding supported by the function. They are determined by type parameter.
   */
  threshold(...args: Params<ThresholdOptions>) {
    return this.handle(args, Threshold)
  }
  
  /**
   * Will use [estimateAffine2D] to calculate affine matrix from given [inputs] and [outputs] and then [warpAffine] to transform.
   */
  warpAffine(...args: Params<WarpAffineOptions>) {
    return this.handle(args, WarpAffine)
  }
  
  /**
   * Input should be float type and 1, 3or 4 channels. In doubt use toRgba().
   */
  warpPerspective(...args: Params<WarpPerspectiveOptions>) {
    return this.handle(args, WarpPerspective)
  }
  
  /**
   * converts an input image from one color space to another. In case of a transformation to-from RGB color space, the order of the channels should be specified explicitly (RGB or BGR). Note that the default color format in OpenCV is often referred to as RGB but it is actually BGR (the bytes are reversed). So the first byte in a standard (24-bit) color image will be an 8-bit Blue component, the second byte will be Green, and the third byte will be Red. The fourth, fifth, and sixth bytes would then be the second pixel (Blue, then Green, then Red), and so on.
   */
  cvtColor(...args: Params<CvtColorOptions>) {
    return this.handle(args, CvtColor)
  }
  
  /**
   *  Performs pyramid up or down on an image. PyrUp up samples an image and then blurs it. PyrDown blurs an image and down samples it. By default, size of the output image is computed as 'Size((src.cols+1)/2, (src.rows+1)/2)', but in any case, the following conditions should be satisfied: '|𝚍𝚜𝚝𝚜𝚒𝚣𝚎.𝚠𝚒𝚍𝚝𝚑∗2−src.cols|≤2|𝚍𝚜𝚝𝚜𝚒𝚣𝚎.𝚑𝚎𝚒𝚐𝚑𝚝∗2−src.rows|≤2'.
   */
  pyr(...args: Params<PyrOptions>) {
    return this.handle(args, Pyr)
  }
  
  /**
   * Changes image type to 4 channel RGBA. This is often necessary to render in HTML canvas.
   */
  toRgba(...args: Params<ToRgbaOptions>) {
    return this.handle(args, ToRgba)
  }
  
  /**
   * Return an image which has a src sub region defined by in given rectangle expression
   */
  roi(...args: Params<RoiOptions>) {
    return this.handle(args, Roi)
  }
  
  /**
   * convert an image into a cartoon-like image
   */
  cartoonize(...args: Params<CartoonizeOptions>) {
    return this.handle(args, Cartoonize)
  }
  
  /**
   * Waving like image warp
   */
  wave(...args: Params<WaveOptions>) {
    return this.handle(args, Wave)
  }
  
  /**
   * Finds line segments in a binary image using the probabilistic Hough transform. The function implements the probabilistic Hough transform algorithm for line detection. It returns parsed set of line segments in [line] option. If color is given it will draw lines in [dst]
   */
  houghLinesP(...args: Params<HoughLinesPOptions>) {
    return this.handle(args, HoughLinesP)
  }
  
  /**
   * Convolves an image with the kernel. The function applies an arbitrary linear filter to an image. In-place operation is supported. When the aperture is partially outside the image, the function interpolates outlier pixel values according to the specified border mode
   */
  filter2D(...args: Params<Filter2DOptions>) {
    return this.handle(args, Filter2D)
  }
}