
export const fft_ts: string = "import * as Mirada from 'mirada'\ndeclare var cv: Mirada.CV\n\n(async () => {\n  const src = await Mirada.fromUrl('lenna.jpg')\n  cv.cvtColor(src, src, cv.COLOR_RGB2RGBA)\n  cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY, 0)\n\n  // get optimal size of DFT\n  let optimalRows = cv.getOptimalDFTSize(src.rows)\n  let optimalCols = cv.getOptimalDFTSize(src.cols)\n  let s0 = cv.Scalar.all(0)\n  let padded = new cv.Mat()\n  cv.copyMakeBorder(src, padded, 0, optimalRows - src.rows, 0, optimalCols - src.cols, cv.BORDER_CONSTANT, s0)\n\n  // use cv.MatVector to distribute space for real part and imaginary part\n  let plane0 = new cv.Mat()\n  padded.convertTo(plane0, cv.CV_32F)\n  let planes = new cv.MatVector()\n  let complexI = new cv.Mat()\n  let plane1 = cv.Mat.zeros(padded.rows, padded.cols, cv.CV_32F)\n  planes.push_back(plane0)\n  planes.push_back(plane1)\n  cv.merge(planes, complexI)\n\n  // in-place dft transform\n  cv.dft(complexI, complexI)\n\n  // compute log(1 + sqrt(Re(DFT(img))**2 + Im(DFT(img))**2))\n  cv.split(complexI, planes)\n  cv.magnitude(planes.get(0), planes.get(1), planes.get(0))\n  let mag = planes.get(0)\n  let m1 = cv.Mat.ones(mag.rows, mag.cols, mag.type())\n  cv.add(mag, m1, mag)\n  cv.log(mag, mag)\n\n  // crop the spectrum, if it has an odd number of rows or columns\n  let rect = new cv.Rect(0, 0, mag.cols & -2, mag.rows & -2)\n  mag = mag.roi(rect)\n\n  // rearrange the quadrants of Fourier image\n  // so that the origin is at the image center\n  let cx = mag.cols / 2\n  let cy = mag.rows / 2\n  let tmp = new cv.Mat()\n\n  let rect0 = new cv.Rect(0, 0, cx, cy)\n  let rect1 = new cv.Rect(cx, 0, cx, cy)\n  let rect2 = new cv.Rect(0, cy, cx, cy)\n  let rect3 = new cv.Rect(cx, cy, cx, cy)\n\n  let q0 = mag.roi(rect0)\n  let q1 = mag.roi(rect1)\n  let q2 = mag.roi(rect2)\n  let q3 = mag.roi(rect3)\n\n  // exchange 1 and 4 quadrants\n  q0.copyTo(tmp)\n  q3.copyTo(q0)\n  tmp.copyTo(q3)\n\n  // exchange 2 and 3 quadrants\n  q1.copyTo(tmp)\n  q2.copyTo(q1)\n  tmp.copyTo(q2)\n\n  // The pixel value of cv.CV_32S type image ranges from 0 to 1.\n  cv.normalize(mag, mag, 0, 1, cv.NORM_MINMAX)\n  const output = Mirada.toRgba(mag)\n  cv.imshow(document.getElementById('outputCanvas')!, output)\n  src.delete()\n  padded.delete()\n  planes.delete()\n  complexI.delete()\n  m1.delete()\n  tmp.delete()\n  output.delete()\n})()\n";
