
export const lucasKanadeOpticalFlow_ts: string = "\n// import * as Mirada_ from 'mirada'\n// declare var Mirada: typeof Mirada_\n  ; (async () => {\nlet videoInput = document.getElementById('videoInput')! as HTMLVideoElement\n\nfunction executeCode(){\n      // let video = document.getElementById('videoInput')!;\n    let cap = new cv.VideoCapture(videoInput);\n\n    // parameters for ShiTomasi corner detection\n    let [maxCorners, qualityLevel, minDistance, blockSize] = [30, 0.3, 7, 7];\n\n    // parameters for lucas kanade optical flow\n    let winSize = new cv.Size(15, 15);\n    let maxLevel = 2;\n    let criteria = new cv.TermCriteria(cv.TERM_CRITERIA_EPS | cv.TERM_CRITERIA_COUNT, 10, 0.03);\n\n    // create some random colors\n    let color: cv.Scalar[] = [];\n    for (let i = 0; i < maxCorners; i++) {\n      color.push(new cv.Scalar(Math.round(Math.random() * 255), Math.round(Math.random() * 255),\n        Math.round(Math.random() * 255), 255));\n    }\n\n    // take first frame and find corners in it\n    let oldFrame = new cv.Mat(videoInput.height, videoInput.width, cv.CV_8UC4);\n    cap.read(oldFrame);\n    let oldGray = new cv.Mat();\n    cv.cvtColor(oldFrame, oldGray, cv.COLOR_RGB2GRAY);\n    let p0 = new cv.Mat();\n    let none = new cv.Mat();\n    cv.goodFeaturesToTrack(oldGray, p0, maxCorners, qualityLevel, minDistance, none, blockSize);\n\n    // Create a mask image for drawing purposes\n    let zeroEle = new cv.Scalar(0, 0, 0, 255);\n    let mask = new cv.Mat(oldFrame.rows, oldFrame.cols, oldFrame.type(), zeroEle);\n\n    let frame = new cv.Mat(videoInput.height, videoInput.width, cv.CV_8UC4);\n    let frameGray = new cv.Mat();\n    let p1 = new cv.Mat();\n    let st = new cv.Mat();\n    let err = new cv.Mat();\n\n    const FPS = 30;\n    function processVideo() {\n      try {\n        if (!streaming) {\n          // clean and stop.\n          frame.delete(); oldGray.delete(); p0.delete(); p1.delete(); err.delete(); mask.delete();\n          return;\n        }\n        let begin = Date.now();\n\n        // start processing.\n        cap.read(frame);\n        cv.cvtColor(frame, frameGray, cv.COLOR_RGBA2GRAY);\n\n        // calculate optical flow\n        cv.calcOpticalFlowPyrLK(oldGray, frameGray, p0, p1, st, err, winSize, maxLevel, criteria);\n\n        // select good points\n        let goodNew = [];\n        let goodOld = [];\n        for (let i = 0; i < st.rows; i++) {\n          if (st.data[i] === 1) {\n            goodNew.push(new cv.Point(p1.data32F[i * 2], p1.data32F[i * 2 + 1]));\n            goodOld.push(new cv.Point(p0.data32F[i * 2], p0.data32F[i * 2 + 1]));\n          }\n        }\n\n        // draw the tracks\n        for (let i = 0; i < goodNew.length; i++) {\n          cv.line(mask, goodNew[i], goodOld[i], color[i], 2);\n          cv.circle(frame, goodNew[i], 5, color[i], -1);\n        }\n        cv.add(frame, mask, frame);\n\n        cv.imshow('canvasOutput', frame);\n\n        // now update the previous frame and previous points\n        frameGray.copyTo(oldGray);\n        p0.delete(); p0 = null;\n        p0 = new cv.Mat(goodNew.length, 1, cv.CV_32FC2);\n        for (let i = 0; i < goodNew.length; i++) {\n          p0.data32F[i * 2] = goodNew[i].x;\n          p0.data32F[i * 2 + 1] = goodNew[i].y;\n        }\n\n        // schedule the next one.\n        let delay = 1000 / FPS - (Date.now() - begin);\n        setTimeout(processVideo, delay);\n      } catch (err) {\n        // utils.printError(err);\n        console.error(err);\n      }\n    };\n\n    // schedule the first one.\n    setTimeout(processVideo, 0);\n}\n\n\n\n\n// utils.loadCode('codeSnippet', 'codeEditor');\n\nlet streaming = false;\n// let startAndStop = document.getElementById('startAndStop');\n\n// startAndStop.addEventListener('click', () => {\n//     if (!streaming) {\n//         utils.clearError();\n//         videoInput.play().then(() => {\n//             onVideoStarted();\n//         });\n//     } else {\n//         videoInput.pause();\n//         videoInput.currentTime = 0;\n//         onVideoStopped();\n//     }\n// });\n\n    videoInput.addEventListener('canplay', async () => {\n        // startAndStop.removeAttribute('disabled');\n streaming = true;\n  await videoInput.play()\n  // await onVideoStarted()\n  videoInput.height = videoInput.width * (videoInput.videoHeight / videoInput.videoWidth);\n  streaming = true;\n  executeCode()\n    });\n\n// async function play(){\n  // await videoInput.play()\n  // await onVideoStarted()\n  // videoInput.height = videoInput.width * (videoInput.videoHeight / videoInput.videoWidth);\nvideoInput.src = 'https://cancerberosgx.github.io/demos/opencv.js/js_assets/box.mp4'\n// }\n\n// function onVideoStarted() {\n//     // streaming = true;\n//     // startAndStop.innerText = 'Stop';\n//     videoInput.height = videoInput.width * (videoInput.videoHeight / videoInput.videoWidth);\n//     // utils.executeCode('codeEditor');\n// }\n\n// function onVideoStopped() {\n//     streaming = false;\n//     startAndStop.innerText = 'Start';\n// }\n\n// videoInput.addEventListener('ended', () => {\n//     onVideoStopped();\n// });\n\n// utils.loadOpenCv(() => {\n//     videoInput.addEventListener('canplay', () => {\n//         startAndStop.removeAttribute('disabled');\n//     });\n//     videoInput.src = 'box.mp4';\n// });\n\n\n  })()\n";
