
export const lucasKanadeOpticalFlow_ts: string = "import * as Mirada from 'mirada'\ndeclare var cv: Mirada.CV\n\n(async () => {\n  let videoInput = document.getElementById('videoInput')! as HTMLVideoElement\n  const canvas = document.getElementById('outputCanvas')! as HTMLCanvasElement\n  let cap = new cv.VideoCapture(videoInput)\n  let [maxCorners, qualityLevel, minDistance, blockSize] = [30, 0.3, 7, 7]\n  // parameters for lucas kanade optical flow\n  let winSize = new cv.Size(15, 15)\n  let maxLevel = 2\n  let criteria = new cv.TermCriteria(cv.TermCriteria_EPS | cv.TermCriteria_COUNT, 10, 0.03)\n  // create some random colors\n  let color: Mirada.Scalar[] = []\n  for (let i = 0; i < maxCorners; i++) {\n    color.push(\n      new cv.Scalar(\n        Math.round(Math.random() * 255),\n        Math.round(Math.random() * 255),\n        Math.round(Math.random() * 255),\n        255\n      )\n    )\n  }\n  let frameGray = new cv.Mat()\n  let oldFrame = new cv.Mat(videoInput.height, videoInput.width, cv.CV_8UC4)\n  let oldGray = new cv.Mat()\n  let p1 = new cv.Mat()\n  let st = new cv.Mat()\n  let err = new cv.Mat()\n  const FPS = 30\n  const v = new Mirada.CameraHelper(videoInput, canvas, processVideo)\n  setTimeout(()=>v.start(), 0)\n  setTimeout(()=>v.stop(), 15000)\n\n  async function processVideo() {\n    await new Promise(resolve => setTimeout(resolve, 500))\n    cap.read(oldFrame)\n    cv.cvtColor(oldFrame, oldGray, cv.COLOR_RGB2GRAY)\n    let p0 = new cv.Mat()\n    let none = new cv.Mat()\n    let zeroEle = new cv.Scalar(0, 0, 0, 255)\n    cv.goodFeaturesToTrack(oldGray, p0, maxCorners, qualityLevel, minDistance, none, blockSize)\n    // Create a mask image for drawing purposes\n    let mask = new cv.Mat(oldFrame.rows, oldFrame.cols, oldFrame.type(), zeroEle)\n    let frame = new cv.Mat(videoInput.height, videoInput.width, cv.CV_8UC4)\n    f()\n    function f() {\n      try {\n        if (!v.streaming) {\n          frame.delete()\n          oldGray.delete()\n          p0.delete()\n          p1.delete()\n          err.delete()\n          mask.delete()\n          return\n        }\n        let begin = Date.now()\n        cap.read(frame)\n        cv.cvtColor(frame, frameGray, cv.COLOR_RGBA2GRAY)\n        // calculate optical flow\n        cv.calcOpticalFlowPyrLK(oldGray, frameGray, p0, p1, st, err, winSize, maxLevel, criteria)\n        // select good points\n        let goodNew = []\n        let goodOld = []\n        for (let i = 0; i < st.rows; i++) {\n          if (st.data[i] === 1) {\n            goodNew.push(new cv.Point(p1.data32F[i * 2], p1.data32F[i * 2 + 1]))\n            goodOld.push(new cv.Point(p0.data32F[i * 2], p0.data32F[i * 2 + 1]))\n          }\n        }\n        // draw the tracks\n        for (let i = 0; i < goodNew.length; i++) {\n          cv.line(mask, goodNew[i], goodOld[i], color[i], 2)\n          cv.circle(frame, goodNew[i], 5, color[i], -1)\n        }\n        cv.add(frame, mask, frame)\n        cv.imshow(canvas, frame)\n        // now update the previous frame and previous points\n        frameGray.copyTo(oldGray)\n        p0.delete()\n        p0 = new cv.Mat(goodNew.length, 1, cv.CV_32FC2)\n        for (let i = 0; i < goodNew.length; i++) {\n          p0.data32F[i * 2] = goodNew[i].x\n          p0.data32F[i * 2 + 1] = goodNew[i].y\n        }\n        // schedule the next one.\n        let delay = 1000 / FPS - (Date.now() - begin)\n        setTimeout(f, delay)\n      } catch (err) {\n        console.error(err)\n      }\n    }\n  }\n})()\n";
