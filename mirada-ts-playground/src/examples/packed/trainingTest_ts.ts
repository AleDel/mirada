
export const trainingTest_ts: string = "// import test from 'ava'\n// import * as jimp from 'jimp'\n// import { loadOpencv } from '../src'\n// import { loadMirada } from './testUtil';\n// import { randomFloatBetween, array } from 'misc-utils-of-mine-generic';\n\n// test.before(loadMirada)\n\n// function doubles(l: number, min: number, max: number){\n//  return  array(l).map(n=>randomFloatBetween(min, max))\n// }\n// test.skip('library loads manually without proxy', async t => {\n//   t.true(true)\n//   // await loadOpencv()\n\n//   //  const NTRAINING_SAMPLES = 100;\n//   //   const  FRAC_LINEAR_SEP = 0.9\n\n//   //       // Data for visual representation\n//   //   const width = 512, height = 512;\n//   //   const I = cv.Mat.zeros(height, width, cv.CV_8UC3);\n//   //       // --------------------- 1. Set up training data randomly---------------------------------------\n//   //       const trainData = new cv.Mat(2 * NTRAINING_SAMPLES, 2, cv.CV_32F);\n//   //       const labels = new cv.Mat(2 * NTRAINING_SAMPLES, 1, cv.CV_32S);\n//   //       // Random rng = new cv.Random(100); // Random value generation class\n//   //       // Set up the linearly separable part of the training data\n//   //       const nLinearSamples =Math.round (FRAC_LINEAR_SEP * NTRAINING_SAMPLES);\n//   //       // Generate random points for the class 1\n//   //       let trainClass = trainData.rowRange(0, nLinearSamples);\n//   //       // The x coordinate of the points is in [0, 0.4)\n//   //       let c = trainClass.colRange(0, 1);\n//   //       let cData = array(Math.round (c.total() * c.channels()))\n//   //     let  cDataDbl = doubles(cData.length, 0, 0.4 * width)\n//   //       for (let i = 0; i < cData.length; i++) {\n//   //           cData[i] = cDataDbl[i];\n//   //       }\n//   //       c.put(0, 0, cData);\n//   //       // The y coordinate of the points is in [0, 1)\n//   //       c = trainClass.colRange(1, 2);\n//   //       cData = array(c.total() * c.channels())\n//   //       cDataDbl = doubles(cData.length, 0, height) \n//   //       for (let i = 0; i < cData.length; i++) {\n//   //           cData[i] = cDataDbl[i];\n//   //       }\n//   //       c.put(0, 0, cData);\n//   //       // Generate random points for the class 2\n//   //       trainClass = trainData.rowRange(2 * NTRAINING_SAMPLES - nLinearSamples, 2 * NTRAINING_SAMPLES);\n//   //       // The x coordinate of the points is in [0.6, 1]\n//   //       c = trainClass.colRange(0, 1);\n//   //       cData = array(  (c.total() * c.channels()))\n//   //       cDataDbl =  doubles(cData.length, 0.6 * width, width) \n//   //       for (let i = 0; i < cData.length; i++) {\n//   //           cData[i] = cDataDbl[i];\n//   //       }\n//   //       c.put(0, 0, cData);\n//   //       // The y coordinate of the points is in [0, 1)\n//   //       c = trainClass.colRange(1, 2);\n//   //       cData = array(c.total() * c.channels())\n//   //       cDataDbl =  doubles(cData.length, 0, height) \n//   //       for (let i = 0; i < cData.length; i++) {\n//   //           cData[i] = cDataDbl[i];\n//   //       }\n//   //       c.put(0, 0, cData);\n//   //       // ------------------ Set up the non-linearly separable part of the training data ---------------\n//   //       // Generate random points for the classes 1 and 2\n//   //       trainClass = trainData.rowRange(nLinearSamples, 2 * NTRAINING_SAMPLES - nLinearSamples);\n//   //       // The x coordinate of the points is in [0.4, 0.6)\n//   //       c = trainClass.colRange(0, 1);\n//   //       cData =array((c.total() * c.channels()))\n//   //       cDataDbl = doubles(cData.length, 0.4 * width, 0.6 * width) \n//   //       for (let i = 0; i < cData.length; i++) {\n//   //           cData[i] =cDataDbl[i];\n//   //       }\n//   //       c.put(0, 0, cData);\n//   //       // The y coordinate of the points is in [0, 1)\n//   //       c = trainClass.colRange(1, 2);\n//   //       cData = array((c.total() * c.channels()))\n//   //       cDataDbl =  doubles(cData.length, 0, height)\n//   //       for (let i = 0; i < cData.length; i++) {\n//   //           cData[i] = cDataDbl[i];\n//   //       }\n//   //       c.put(0, 0, cData);\n//   //       // ------------------------- Set up the labels for the classes---------------------------------\n//   //       labels.rowRange(0, NTRAINING_SAMPLES).setTo(new cv.Scalar(1) as any); // Class 1\n//   //       labels.rowRange(NTRAINING_SAMPLES, 2 * NTRAINING_SAMPLES).setTo(new cv.Scalar(2) as any); // Class 2\n//   //       // ------------------------ 2. Set up the support vector machines parameters--------------------\n//   //       // console.log(\"Starting training process\");\n//   //       const svm = cv.SVM.create();\n\n//   //   //      svm->setType(SVM::C_SVC);\n//   //   // svm->setKernel(SVM::LINEAR);\n//   //   // svm->setTermCriteria(TermCriteria(TermCriteria::MAX_ITER, 100, 1e-6));\n//   //   // svm->train(train\n\n//   //       svm.setType(cv.SVM.C_SVC);\n//   //       svm.setC(0.1);\n//   //       svm.setKernel(cv.SVM.LINEAR);\n//   //       svm.setTermCriteria(new cv.TermCriteria(cv.INTER_MAX,  1e7, 1e-6));\n//   //       // ------------------------ 3. Train the svm----------------------------------------------------\n//   //       svm.train(trainData, Ml.ROW_SAMPLE, labels);\n//   //       console.log(\"Finished training process\");\n//   //       // ------------------------ 4. Show the decision regions----------------------------------------\n//   //      let IData = array  (I.total() * I.channels())\n//   //       let sampleMat = new cv.Mat(1, 2, cv.CV_32F);\n//   //       let sampleMatData = array(sampleMat.total() * sampleMat.channels())\n//   //       for (let i = 0; i < I.rows(); i++) {\n//   //           for (let j = 0; j < I.cols(); j++) {\n//   //               sampleMatData[0] = j;\n//   //               sampleMatData[1] = i;\n//   //               sampleMat.put(0, 0, sampleMatData);\n//   //               let response = svm.predict(sampleMat);\n//   //               if (response == 1) {\n//   //                   IData[(i * I.cols() + j) * I.channels()] = 0;\n//   //                   IData[(i * I.cols() + j) * I.channels() + 1] = 100;\n//   //                   IData[(i * I.cols() + j) * I.channels() + 2] = 0;\n//   //               } else if (response == 2) {\n//   //                   IData[(i * I.cols() + j) * I.channels()] = 100;\n//   //                   IData[(i * I.cols() + j) * I.channels() + 1] = 0;\n//   //                   IData[(i * I.cols() + j) * I.channels() + 2] = 0;\n//   //               }\n//   //           }\n//   //       }\n//   //       I.put(0, 0, IData);\n//   //       // ----------------------- 5. Show the training data--------------------------------------------\n//   //       let thick = -1;\n//   //       let lineType = cv.LINE_8//Imgproc.LINE_8;\n//   //       let px, py;\n//   //       // Class 1\n//   //       let trainDataData = array (trainData.total() * trainData.channels())\n//   //       trainData.get(0, 0, trainDataData);\n//   //       for (let i = 0; i < NTRAINING_SAMPLES; i++) {\n//   //           px = trainDataData[i * trainData.cols()];\n//   //           py = trainDataData[i * trainData.cols() + 1];\n//   //           cv.circle(I, new cv.Point(px, py), 3, new cv.Scalar(0, 255, 0), thick, lineType, 0);\n//   //       }\n//   //       // Class 2\n//   //       for (let i = NTRAINING_SAMPLES; i < 2 * NTRAINING_SAMPLES; ++i) {\n//   //           px = trainDataData[i * trainData.cols()];\n//   //           py = trainDataData[i * trainData.cols() + 1];\n//   //           cv.circle(I, new cv.Point(px, py), 3, new cv.Scalar(255, 0, 0), thick, lineType, 0);\n//   //       }\n//   //       // ------------------------- 6. Show support vectors--------------------------------------------\n//   //       thick = 2;\n//   //       let sv = svm.getUncompressedSupportVectors();\n//   //      let  svData = array(sv.total() * sv.channels())\n//   //       sv.get(0, 0, svData);\n//   //       for (let i = 0; i < sv.rows(); i++) {\n//   //           cv.circle(I, new cv.Point(svData[i * sv.cols()], svData[i * sv.cols() + 1]), 6, new cv.Scalar(128, 128, 128),\n//   //                   thick, lineType, 0);\n//   //       }\n//   //       // cv.imwrite(\"result.png\", I); // save the Image\n//   //       // HighGui.imshow(\"SVM for Non-Linear Training Data\", I); // show it to the user\n//   //       // HighGui.waitKey();\n//   //       // System.exit(0);\n//   //   }\n\n// })\n";
