
export const dnnHighLevelGeneration_ts: string = "import * as cv from 'mirada'\nimport * as Mirada from 'mirada';\n\n(async () => {\n  const canvas = document.getElementById('outputCanvas')! as HTMLCanvasElement\n  var image: Mirada.Mat = cv.imread(canvas)\n\n  // This example is currently failing when loading the model pointilism.onnx which I download from onnx.org\n  // github repo Probably the problem is related with encoding I guess pixels in uint8 vs uint 16. Tried\n  // different ways of loading from file path or buffer, but always fail while other models don't \n  // so I guess is a problem with the content. I leave it here since perhaps somebody can help me fix it\n\n  // this should work as in the other examples but it throws:\n  const f = await Mirada.loadDataFile('pointilism.onnx')\n  const model = cv.readNetFromONNX(f)  //  <---- throws here\n\n  // this tries to load it as buffer so there0s bo FS involved but also throws similarly\n\n  // const r = await fetch('pointilism.onnx')\n  // const f = new Uint8ClampedArray(await r.arrayBuffer())\n  // //@ts-ignore\n  // const model = cv.readNetFromONNX1(f) \n\n  // using emscripten FS directly also fails:\n\n  // const r = await fetch('pointilism.onnx')\n  // if (!cv.FS.readdir('/').includes('pointilism.onnx')) {\n  //  await cv.FS.createDataFile('/', 'pointilism.onnx', new Uint8ClampedArray(await r.arrayBuffer()), true, true, true)\n  // }\n  // const model = cv.readNetFromONNX('/pointilism.onnx') \n\n  const size = new cv.Size(512, 512)\n  // Whether to swap Red and Blue channels since OpenCV loads images in BGR\n  let swapRB = true\n  // rescale the image (image * scale)\n  let scale = 1.0\n  const mean = new cv.Scalar() // mean to subtract (e.g: 103.939, 116.779, 123.68)\n  // Set the transformations we want to apply\n  model.setInputParams(scale, size, mean, swapRB)\n  // Network Forward pass\n  let out = new cv.Mat()\n  model.generate(image, out)\n  cv.imshow(canvas, out)\n  image.delete()\n  out.delete()\n})()\n";
